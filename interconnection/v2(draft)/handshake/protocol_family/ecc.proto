// Copyright 2023 Ant Group Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package org.interconnection.v2.protocol;

//===================================//
//  Protos used in HandshakeRequest  //
//===================================//

message EccProtocolProposal {
  repeated int32 supported_versions = 1;

  // enum CurveType
  repeated int32 curves = 2;

  // enum HashToCurveStrategy
  repeated int32 hash2curve_strategies = 3;

  // enum PointOctetFormat, 点的序列化格式
  repeated int32 point_octet_format = 4;
}

enum CurveType {
  CURVE_TYPE_UNSPECIFIED = 0;
  CURVE_TYPE_CURVE25519 = 1;
  CURVE_TYPE_SM2 = 2;
}

enum HashToCurveStrategy {
  HASH_TO_CURVE_STRATEGY_UNSPECIFIED = 0;

  // https://eprint.iacr.org/2009/226.pdf
  // Auto select the most suitable algorithm:
  //  - SHA2: select between SHA-224, SHA-256, SHA-384, SHA-512
  //  - SHA3: select between SHA3-224, SHA3-256, SHA3-384, SHA3-512
  //  - SM: Current only support SM3.
  // Performance: This method is very fast, but it is susceptible to timing
  // attacks.
  HASH_TO_CURVE_STRATEGY_TRY_AND_INCREMENT_SHA2 = 1;
  HASH_TO_CURVE_STRATEGY_TRY_AND_INCREMENT_SHA3 = 2;
  HASH_TO_CURVE_STRATEGY_TRY_AND_INCREMENT_SM = 3;

  // Just like TryAndIncrement; but use re-hash instead of increment when try
  // fails.
  HASH_TO_CURVE_STRATEGY_TRY_AND_REHASH_SHA2 = 10;
  HASH_TO_CURVE_STRATEGY_TRY_AND_REHASH_SHA3 = 11;
  HASH_TO_CURVE_STRATEGY_TRY_AND_REHASH_SM = 12;

  // Directly output the hash value as the x-coordinate of the point without any
  // verification. And there is no y-coordinate info in output point.

  // The applicable scenarios of this scheme are very limited, and the following
  // requirements must be met:
  //  - The calculation of points on curve depends only on the x-coordinate
  //  - The usage scenario of the curve allows any hash value to be used as the
  //    initial point, even if the point is not on the curve.
  // It is currently known that this strategy can be safely used when curve is
  // Curve25519 and scene is ECDH. Do not choose this strategy for other
  // purpose.
  HASH_TO_CURVE_STRATEGY_HASH_AS_POINT_X_SHA2 = 20;
  HASH_TO_CURVE_STRATEGY_HASH_AS_POINT_X_SHA3 = 21;
  HASH_TO_CURVE_STRATEGY_HASH_AS_POINT_X_SM = 22; // Currently only support SM3

  // Below is IRTF CFRG hash-to-curve standard (draft):
  // https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/

  // This strategy is a collection of the following methods, and SPI will
  // automatically select the applicable method according to different curves:
  //  - SHA-256_SSWU_NU_
  //  - SHA-384_SSWU_NU_
  //  - SHA-512_SSWU_NU_
  //  - SHA-512_ELL2_NU_
  //  - SHAKE256_ELL2_NU_
  // Performance: This strategy takes 6 times longer than TryAndIncrement on SM2
  // Warning: The output of this strategy is not uniformly distributed on the
  // elliptic curve G.
  HASH_TO_CURVE_STRATEGY_ENCODE_TO_CURVE = 30;  // Not implemented, do not choose me

  // This strategy is a collection of the following methods, and SPI will
  // automatically select the applicable method according to different curves:
  //  - SHA-256_SSWU_RO_
  //  - SHA-384_SSWU_RO_
  //  - SHA-512_SSWU_RO_
  //  - SHA-512_ELL2_RO_
  //  - SHAKE256_ELL2_RO_
  // Performance: This strategy takes 12 times longer than TryAndIncrement on
  // SM2
  HASH_TO_CURVE_STRATEGY_HASH_TO_CURVE = 40;  // Not implemented, do not choose me
}

// Elliptic curve point Octet-String format
// See SECG standard for details: SEC 1, section 2.3. https://www.secg.org/
enum PointOctetFormat {
  POINT_OCTET_FORMAT_UNSPECIFIED = 0;

  // 不压缩，多个点连续存储，例如 x1||y1||x2||y2||x3||y3...
  // x 和 y 都占用整数个 byte，
  // 例如 255bits 的数字占用 32bytes, 小端序，buffer 最后1bit补0
  // 对于 X25529, 本身只有 X 坐标，则多个点序列化只排列 X 坐标
  POINT_OCTET_FORMAT_UNCOMPRESSED = 1;

  // ANSI X9.62 compressed format
  // The point is encoded as z||x, where the octet z specifies which solution of
  // the quadratic equation y is.
  // if y is even, output 0x02||x
  // if y is odd, output 0x03||x
  // if point is inf, output 0x00
  POINT_OCTET_FORMAT_X962_COMPRESSED = 3;

  // ANSI X9.62 uncompressed format
  // The point is encoded as z||x||y, where z is the octet 0x04
  POINT_OCTET_FORMAT_X962_UNCOMPRESSED = 4;

  // ANSI X9.62 hybrid format
  // The point is encoded as z||x||y, where the octet z specifies which solution
  // of the quadratic equation y is. It's basically the uncompressed encoding
  // but the first byte encodes the evenness of y just like in compressed
  // format. It's designated by 0x06 and 0x07 in the first byte, and they have
  // the same meaning as 0x02 and 0x03 in compressed.
  POINT_OCTET_FORMAT_X962_HYBRID = 5;
};

//===================================//
//  Protos used in HandshakeResponse  //
//===================================//

message EccProtocolResult {
  int32 version = 1;
  // 选定的曲线
  int32 curve = 2;
  // HashToCurve 策略
  int32 hash2curve_strategy = 3;
  // 点的序列化格式
  int32 point_octet_format = 4;
}
